This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-04T07:31:00.756Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Directory Structure
================================================================
backend/
  cmd/
    server/
      main.go
  data/
    locations.json
  internal/
    api/
      handlers.go
      middleware.go
      routes.go
    config/
      config_test.go
      config.go
    models/
      location.go
    openai/
      client.go
    repositories/
      redisrepo.go
      repository.go
    services/
      ai_service.go
      location_service.go
    utils/
      geo.go
      logger.go
  scripts/
    init_redis.go
    init_redis.sh
  docker-compose.yml
  go.mod
  go.sum
  Makefile
frontend/
  public/
    index.html
  src/
    components/
      LeaderboardList.jsx
      MapView.jsx
      StreetView.jsx
    pages/
      HomePage.jsx
      MapAndLeaderboardPage.jsx
    services/
      api.js
    App.tsx
    index.tsx
  package.json
  tsconfig.json
.gitignore
README.md

================================================================
Files
================================================================

================
File: backend/cmd/server/main.go
================
package main

import (
	"fmt"
	"log"

	"github.com/my-streetview-project/backend/internal/api"
	"github.com/my-streetview-project/backend/internal/config"
	"github.com/my-streetview-project/backend/internal/repositories"
	"github.com/my-streetview-project/backend/internal/services"

	"github.com/gin-gonic/gin"
)

func main() {
	// Load configuration
	cfg := config.New()

	// Initialize Redis repository
	repo, err := repositories.NewRedisRepository(cfg)
	if err != nil {
		log.Fatalf("Failed to initialize repository: %v", err)
	}

	// Initialize services
	aiService := services.NewAIService(cfg, repo)
	locationService := services.NewLocationService(repo, aiService)

	// Setup Gin router
	r := gin.Default()

	// Add CORS middleware
	r.Use(api.CORSMiddleware())

	// Setup routes
	api.SetupRoutes(r, locationService, aiService)

	addr := ":8080" // 默认端口
	fmt.Printf("Server running on %s\n", addr)
	if err := r.Run(addr); err != nil {
		log.Fatalf("Failed to run server: %v", err)
	}
}

================
File: backend/data/locations.json
================
[
  {
    "location_id": "loc_001",
    "latitude": 35.6762,
    "longitude": 139.6503,
    "likes": 10,
    "description": "东京涩谷十字路口 - 世界上最繁忙的十字路口之一，每天有数十万人通过"
  },
  {
    "location_id": "loc_002",
    "latitude": 48.8584,
    "longitude": 2.2945,
    "likes": 8,
    "description": "巴黎埃菲尔铁塔 - 法国巴黎的标志性建筑，世界上最著名的建筑物之一"
  },
  {
    "location_id": "loc_003",
    "latitude": 40.7580,
    "longitude": -73.9855,
    "likes": 15,
    "description": "纽约时代广场 - 纽约市最受欢迎的旅游景点之一，以其巨大的广告牌和霓虹灯而闻名"
  },
  {
    "location_id": "loc_004",
    "latitude": 51.5007,
    "longitude": -0.1246,
    "likes": 0,
    "description": "伦敦大本钟 - 英国议会大厦的标志性钟楼，世界上最著名的时钟之一"
  },
  {
    "location_id": "loc_005",
    "latitude": 40.4319,
    "longitude": 116.5704,
    "likes": 0,
    "description": "北京长城慕田峪 - 中国最著名的文化遗产，世界七大奇迹之一"
  },
  {
    "location_id": "loc_006",
    "latitude": -22.9519,
    "longitude": -43.2105,
    "likes": 0,
    "description": "里约热内卢基督像 - 巴西最著名的地标，俯瞰整个里约热内卢市"
  },
  {
    "location_id": "loc_007",
    "latitude": 27.1751,
    "longitude": 78.0421,
    "likes": 0,
    "description": "印度泰姬陵 - 世界上最美丽的建筑之一，象征永恒的爱情"
  },
  {
    "location_id": "loc_008",
    "latitude": 41.8902,
    "longitude": 12.4922,
    "likes": 0,
    "description": "罗马斗兽场 - 古罗马帝国最著名的建筑，见证了数千年的历史"
  },
  {
    "location_id": "loc_009",
    "latitude": 25.1972,
    "longitude": 55.2744,
    "likes": 0,
    "description": "迪拜哈利法塔 - 世界最高建筑，现代建筑奇迹"
  },
  {
    "location_id": "loc_010",
    "latitude": -33.8568,
    "longitude": 151.2153,
    "likes": 0,
    "description": "悉尼歌剧院 - 澳大利亚最著名的地标，独特的贝壳形建筑设计"
  },
  {
    "location_id": "loc_011",
    "latitude": 43.0428,
    "longitude": -76.1432,
    "likes": 0,
    "description": "美国大峡谷国家公园 - 世界上最壮观的自然奇观之一"
  },
  {
    "location_id": "loc_012",
    "latitude": 31.6240,
    "longitude": 74.8747,
    "likes": 0,
    "description": "印度金庙 - 锡克教最神圣的寺庙，金碧辉煌的建筑"
  }
]

================
File: backend/internal/api/handlers.go
================
package api

import (
	"context"
	"net/http"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/my-streetview-project/backend/internal/services"
)

type Handlers struct {
	locationService *services.LocationService
	aiService       *services.AIService
}

func NewHandlers(ls *services.LocationService, ai *services.AIService) *Handlers {
	return &Handlers{locationService: ls, aiService: ai}
}

func (h *Handlers) GetRandomLocation(c *gin.Context) {
	_, cancel := context.WithTimeout(c.Request.Context(), 10*time.Second)
	defer cancel()

	loc, err := h.locationService.GetRandomLocation()
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"success": false, "error": err.Error()})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"success": true,
		"data": gin.H{
			"location_id": loc.LocationID,
			"latitude":    loc.Latitude,
			"longitude":   loc.Longitude,
			"likes":       loc.Likes,
		},
		"error": nil,
	})
}

func (h *Handlers) Like(c *gin.Context) {
	var req struct {
		LocationID string `json:"location_id"`
	}
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"success": false, "error": err.Error()})
		return
	}

	likes, err := h.locationService.LikeLocation(req.LocationID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"success": false, "error": err.Error()})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"success": true,
		"data": gin.H{
			"location_id": req.LocationID,
			"likes":       likes,
		},
		"error": nil,
	})
}

func (h *Handlers) Leaderboard(c *gin.Context) {
	var req struct {
		Page     int `json:"page"`
		PageSize int `json:"page_size"`
	}
	if err := c.ShouldBindJSON(&req); err != nil {
		req.Page = 1
		req.PageSize = 10
	}
	if req.Page <= 0 {
		req.Page = 1
	}
	if req.PageSize <= 0 {
		req.PageSize = 10
	}

	list, err := h.locationService.GetLeaderboard(req.Page, req.PageSize)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"success": false, "error": err.Error()})
		return
	}

	c.JSON(http.StatusOK, gin.H{"success": true, "data": list, "error": nil})
}

func (h *Handlers) MapLikes(c *gin.Context) {
	list, err := h.locationService.GetAllLikes()
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"success": false, "error": err.Error()})
		return
	}

	c.JSON(http.StatusOK, gin.H{"success": true, "data": list, "error": nil})
}

func (h *Handlers) GetLocationDescription(c *gin.Context) {
	var req struct {
		LocationID string `json:"location_id"`
	}
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusOK, gin.H{
			"success": false,
			"data":    nil,
			"error":   "无效的请求参数: " + err.Error(),
		})
		return
	}

	loc, err := h.locationService.GetLocationByID(req.LocationID)
	if err != nil {
		c.JSON(http.StatusOK, gin.H{
			"success": false,
			"data":    nil,
			"error":   "位置不存在: " + err.Error(),
		})
		return
	}

	desc, err := h.aiService.GetDescriptionForLocation(loc)
	if err != nil {
		c.JSON(http.StatusOK, gin.H{
			"success": false,
			"data":    nil,
			"error":   "获取位置描述失败: " + err.Error(),
		})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"success": true,
		"data": gin.H{
			"location_id": req.LocationID,
			"description": desc,
		},
		"error": nil,
	})
}

func (h *Handlers) GetLocationByID(c *gin.Context) {
	// For future use if needed
	locationID := c.Param("location_id")
	loc, err := h.locationService.GetLocationByID(locationID)
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"success": false, "error": "location not found"})
		return
	}

	c.JSON(http.StatusOK, gin.H{"success": true, "data": loc, "error": nil})
}

================
File: backend/internal/api/middleware.go
================
package api

import (
    "github.com/gin-gonic/gin"
    "net/http"
)

// Future middleware: Rate limit, CORS, etc.
func RateLimitMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        // TODO: Implement rate limiting
        c.Next()
    }
}

func CORSMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        c.Writer.Header().Set("Access-Control-Allow-Origin", "*")
        c.Writer.Header().Set("Access-Control-Allow-Methods", "POST, GET, OPTIONS")
        c.Writer.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")
        if c.Request.Method == http.MethodOptions {
            c.AbortWithStatus(http.StatusNoContent)
            return
        }
        c.Next()
    }
}

================
File: backend/internal/api/routes.go
================
package api

import (
	"net/http"

	"github.com/gin-gonic/gin"
	"github.com/my-streetview-project/backend/internal/services"
)

func SetupRoutes(r *gin.Engine, ls *services.LocationService, ai *services.AIService) {
	h := NewHandlers(ls, ai)

	// 添加健康检查接口
	r.GET("/health", func(c *gin.Context) {
		c.JSON(http.StatusOK, gin.H{"status": "ok"})
	})

	// Example routes
	r.POST("/random-location", h.GetRandomLocation)
	r.POST("/like", h.Like)
	r.POST("/leaderboard", h.Leaderboard)
	r.POST("/map-likes", h.MapLikes)
	r.POST("/location-description", h.GetLocationDescription)
}

================
File: backend/internal/config/config_test.go
================
package config

import (
	"os"
	"testing"
)

func TestLoadConfig(t *testing.T) {
	// 清理环境变量
	os.Clearenv()

	t.Run("missing required vars", func(t *testing.T) {
		_, err := LoadConfig()
		if err == nil {
			t.Error("应该返回错误当必需的环境变量未设置")
		}
	})

	t.Run("with all required vars", func(t *testing.T) {
		os.Setenv("REDIS_ADDRESS", "localhost:6379")
		os.Setenv("OPENAI_API_KEY", "test-key")

		cfg, err := LoadConfig()
		if err != nil {
			t.Errorf("不应该返回错误: %v", err)
		}

		if cfg.RedisAddress() != "localhost:6379" {
			t.Errorf("RedisAddress 不正确")
		}
		if cfg.OpenAIAPIKey() != "test-key" {
			t.Errorf("OpenAIAPIKey 不正确")
		}
		if cfg.ServerAddress() != ":8080" {
			t.Errorf("ServerAddress 默认值不正确")
		}
	})
}

================
File: backend/internal/config/config.go
================
package config

import (
	"log"
	"os"

	"github.com/joho/godotenv"
)

type Config interface {
	ServerAddress() string
	RedisAddress() string
	OpenAIAPIKey() string
	EnableLocationDescCache() bool
}

type config struct {
	serverAddress      string
	redisAddress       string
	openAIAPIKey       string
	enableLocDescCache bool
}

func (c *config) ServerAddress() string {
	return c.serverAddress
}

func (c *config) RedisAddress() string {
	return c.redisAddress
}

func (c *config) OpenAIAPIKey() string {
	return c.openAIAPIKey
}

func (c *config) EnableLocationDescCache() bool {
	return c.enableLocDescCache
}

func New() Config {
	// 尝试加载 .env 文件
	if err := godotenv.Load(); err != nil {
		log.Printf("警告: 无法加载 .env 文件: %v", err)
	}

	cfg := &config{
		serverAddress:      getEnvOrDefault("SERVER_ADDRESS", ":8080"),
		redisAddress:       getEnvOrDefault("REDIS_ADDRESS", "localhost:6379"),
		openAIAPIKey:       getEnvOrDefault("OPENAI_API_KEY", ""),
		enableLocDescCache: getEnvOrDefault("ENABLE_LOCATION_DESC_CACHE", "true") == "true",
	}

	log.Printf("加载配置:\n"+
		"Server Address: %s\n"+
		"Redis Address: %s\n"+
		"Enable Location Description Cache: %v",
		cfg.serverAddress,
		cfg.redisAddress,
		cfg.enableLocDescCache)

	return cfg
}

func getEnvOrDefault(key, defaultValue string) string {
	if value := os.Getenv(key); value != "" {
		return value
	}
	return defaultValue
}

================
File: backend/internal/models/location.go
================
package models

type Location struct {
    LocationID string  `json:"location_id"`
    Latitude   float64 `json:"latitude"`
    Longitude  float64 `json:"longitude"`
    Likes      int     `json:"likes"`
    // Additional fields such as name, city, country can be added if needed
}

================
File: backend/internal/openai/client.go
================
package openai

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
)

const (
	apiEndpoint = "https://api.openai.com/v1/chat/completions"
	model       = "gpt-4o-mini"
)

type Client interface {
	GenerateLocationDescription(latitude, longitude float64) (string, error)
}

type client struct {
	apiKey     string
	httpClient *http.Client
}

type chatRequest struct {
	Model    string        `json:"model"`
	Messages []chatMessage `json:"messages"`
}

type chatMessage struct {
	Role    string `json:"role"`
	Content string `json:"content"`
}

type chatResponse struct {
	Choices []struct {
		Message struct {
			Content string `json:"content"`
		} `json:"message"`
	} `json:"choices"`
	Error *struct {
		Message string `json:"message"`
	} `json:"error,omitempty"`
}

func NewClient(apiKey string) Client {
	return &client{
		apiKey:     apiKey,
		httpClient: &http.Client{},
	}
}

func (c *client) GenerateLocationDescription(latitude, longitude float64) (string, error) {
	log.Printf("正在请求 OpenAI 生成位置描述 (%.6f, %.6f)", latitude, longitude)

	prompt := fmt.Sprintf(
		"请为经纬度 (%.6f, %.6f) 生成一段简短但生动的位置描述。"+
			"如果是著名地点，简要介绍其特点和历史意义；"+
			"如果是普通地点，描述当地的地理特征和有趣之处。"+
			"可以包含一个有趣的历史趣闻或当地特色。"+
			"要求：\n"+
			"1. 描述要生动有趣\n"+
			"2. 突出地点特色\n"+
			"3. 字数限制在100字以内",
		latitude, longitude,
	)

	reqBody := chatRequest{
		Model: model,
		Messages: []chatMessage{
			{
				Role:    "system",
				Content: "你是一位资深的开发者，同时也是一个环球旅行家，擅长用简洁生动的语言描述世界各地的特色。",
			},
			{
				Role:    "user",
				Content: prompt,
			},
		},
	}

	reqJSON, err := json.Marshal(reqBody)
	if err != nil {
		return "", fmt.Errorf("编码请求失败: %w", err)
	}

	req, err := http.NewRequest("POST", apiEndpoint, bytes.NewBuffer(reqJSON))
	if err != nil {
		return "", fmt.Errorf("创建请求失败: %w", err)
	}

	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Authorization", "Bearer "+c.apiKey)

	log.Printf("发送请求到 OpenAI API...")
	resp, err := c.httpClient.Do(req)
	if err != nil {
		log.Printf("OpenAI API 请求失败: %v", err)
		return "", fmt.Errorf("发送请求失败: %w", err)
	}
	defer resp.Body.Close()

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", fmt.Errorf("读取响应失败: %w", err)
	}

	var chatResp chatResponse
	if err := json.Unmarshal(body, &chatResp); err != nil {
		log.Printf("解析 OpenAI 响应失败: %v", err)
		return "", fmt.Errorf("解析响应失败: %w", err)
	}

	if chatResp.Error != nil {
		log.Printf("OpenAI API 返回错误: %s", chatResp.Error.Message)
		return "", fmt.Errorf("OpenAI API错误: %s", chatResp.Error.Message)
	}

	if len(chatResp.Choices) == 0 {
		log.Printf("OpenAI 未返回任何结果")
		return "", fmt.Errorf("OpenAI未返回任何结果")
	}

	desc := chatResp.Choices[0].Message.Content
	log.Printf("成功获取位置描述: %s", desc)
	return desc, nil
}

================
File: backend/internal/repositories/redisrepo.go
================
package repositories

import (
	"errors"
	"math/rand"
	"time"

	"github.com/my-streetview-project/backend/internal/models"

	"context"
	"fmt"
	"strconv"

	"encoding/json"

	"github.com/redis/go-redis/v9"
)

type RedisConfig interface {
	RedisAddress() string
}

type RedisRepository struct {
	client *redis.Client
}

func NewRedisRepository(cfg RedisConfig) (Repository, error) {
	rdb := redis.NewClient(&redis.Options{
		Addr:            cfg.RedisAddress(),
		DB:              0,
		PoolSize:        10,
		MinIdleConns:    5,
		ConnMaxLifetime: time.Hour,
		ConnMaxIdleTime: 30 * time.Minute,
	})

	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	if err := rdb.Ping(ctx).Err(); err != nil {
		return nil, fmt.Errorf("Redis连接失败: %w", err)
	}

	return &RedisRepository{client: rdb}, nil
}

func (r *RedisRepository) GetRandomLocation() (models.Location, error) {
	ctx := context.Background()
	// Example: get all members from `locations` set and randomly pick one
	locs, err := r.client.SMembers(ctx, "locations").Result()
	if err != nil || len(locs) == 0 {
		return models.Location{}, errors.New("no locations available or redis error")
	}

	rand.Seed(time.Now().UnixNano())
	chosen := locs[rand.Intn(len(locs))]
	return r.GetLocationByID(chosen)
}

func (r *RedisRepository) GetLocationByID(locationID string) (models.Location, error) {
	ctx := context.Background()
	key := fmt.Sprintf("location:%s", locationID)
	fields, err := r.client.HGetAll(ctx, key).Result()
	if err != nil || len(fields) == 0 {
		return models.Location{}, errors.New("location not found")
	}

	// 从 data 字段中解析完整的位置信息
	var loc models.Location
	if data, ok := fields["data"]; ok {
		if err := json.Unmarshal([]byte(data), &loc); err != nil {
			return models.Location{}, fmt.Errorf("解析位置数据失败: %w", err)
		}
		// 确保使用最新的点赞数
		if likes, err := strconv.Atoi(fields["likes"]); err == nil {
			loc.Likes = likes
		}
		return loc, nil
	}

	return models.Location{}, errors.New("invalid location data")
}

func (r *RedisRepository) IncrementLike(locationID string) (int, error) {
	ctx := context.Background()
	locKey := fmt.Sprintf("location:%s", locationID)

	newLikes, err := r.client.HIncrBy(ctx, locKey, "likes", 1).Result()
	if err != nil {
		return 0, err
	}

	// Update leaderboard score
	_, err = r.client.ZAdd(ctx, "location_likes", redis.Z{
		Score:  float64(newLikes),
		Member: locationID,
	}).Result()
	if err != nil {
		return 0, err
	}

	return int(newLikes), nil
}

func (r *RedisRepository) GetLeaderboard(page, pageSize int) ([]models.Location, error) {
	ctx := context.Background()
	start := int64((page - 1) * pageSize)
	stop := start + int64(pageSize) - 1

	ids, err := r.client.ZRevRange(ctx, "location_likes", start, stop).Result()
	if err != nil {
		return nil, err
	}

	var results []models.Location
	for _, id := range ids {
		loc, err := r.GetLocationByID(id)
		if err == nil {
			results = append(results, loc)
		}
	}
	return results, nil
}

func (r *RedisRepository) GetAllLikes() ([]models.Location, error) {
	ctx := context.Background()
	// Get all from ZSET
	ids, err := r.client.ZRange(ctx, "location_likes", 0, -1).Result()
	if err != nil {
		return nil, err
	}

	var results []models.Location
	for _, id := range ids {
		loc, err := r.GetLocationByID(id)
		if err == nil {
			results = append(results, loc)
		}
	}
	return results, nil
}

func (r *RedisRepository) SetAIDescription(locationID, desc string) error {
	ctx := context.Background()
	key := fmt.Sprintf("ai_description:%s", locationID)
	return r.client.HSet(ctx, key, "desc", desc).Err()
}

func (r *RedisRepository) GetAIDescription(locationID string) (string, error) {
	ctx := context.Background()
	key := fmt.Sprintf("ai_description:%s", locationID)
	return r.client.HGet(ctx, key, "desc").Result()
}

================
File: backend/internal/repositories/repository.go
================
package repositories

import (
	"github.com/my-streetview-project/backend/internal/models"
)

type Repository interface {
	GetRandomLocation() (models.Location, error)
	GetLocationByID(locationID string) (models.Location, error)
	IncrementLike(locationID string) (int, error)
	GetLeaderboard(page, pageSize int) ([]models.Location, error)
	GetAllLikes() ([]models.Location, error)
	SetAIDescription(locationID, desc string) error
	GetAIDescription(locationID string) (string, error)
}

================
File: backend/internal/services/ai_service.go
================
package services

import (
	"fmt"
	"log"

	"github.com/my-streetview-project/backend/internal/config"
	"github.com/my-streetview-project/backend/internal/models"
	"github.com/my-streetview-project/backend/internal/openai"
	"github.com/my-streetview-project/backend/internal/repositories"
)

type AIService struct {
	repo   repositories.Repository
	openAI openai.Client
	config config.Config
}

func NewAIService(cfg config.Config, repo repositories.Repository) *AIService {
	return &AIService{
		repo:   repo,
		openAI: openai.NewClient(cfg.OpenAIAPIKey()),
		config: cfg,
	}
}

func (ai *AIService) GetDescriptionForLocation(loc models.Location) (string, error) {
	log.Printf("获取位置描述 (ID: %s, 缓存启用: %v)", loc.LocationID, ai.config.EnableLocationDescCache())

	// 如果启用了缓存，先尝试从缓存获取
	if ai.config.EnableLocationDescCache() {
		desc, err := ai.repo.GetAIDescription(loc.LocationID)
		if err == nil && desc != "" {
			log.Printf("从缓存获取到描述: %s", desc)
			return desc, nil
		}
		log.Printf("缓存中无描述或获取失败: %v", err)
	}

	// 调用OpenAI生成描述
	desc, err := ai.openAI.GenerateLocationDescription(loc.Latitude, loc.Longitude)
	if err != nil {
		log.Printf("OpenAI 调用失败: %v", err)
		// 如果OpenAI调用失败，返回一个默认描述
		desc = fmt.Sprintf("这是位于经纬度(%.4f, %.4f)的一个有趣地点。", loc.Latitude, loc.Longitude)
		log.Printf("使用默认描述: %s", desc)
	}

	// 如果启用了缓存，则缓存结果
	if ai.config.EnableLocationDescCache() {
		if err := ai.repo.SetAIDescription(loc.LocationID, desc); err != nil {
			log.Printf("缓存描述失败: %v", err)
		} else {
			log.Printf("成功缓存描述")
		}
	}

	return desc, nil
}

================
File: backend/internal/services/location_service.go
================
package services

import (
	"github.com/my-streetview-project/backend/internal/models"
	"github.com/my-streetview-project/backend/internal/repositories"
)

type LocationService struct {
	repo      repositories.Repository
	aiService *AIService
}

func NewLocationService(repo repositories.Repository, ai *AIService) *LocationService {
	return &LocationService{repo: repo, aiService: ai}
}

func (ls *LocationService) GetLocationByID(locationID string) (models.Location, error) {
	return ls.repo.GetLocationByID(locationID)
}

func (ls *LocationService) GetRandomLocation() (models.Location, error) {
	return ls.repo.GetRandomLocation()
}

func (ls *LocationService) LikeLocation(locationID string) (int, error) {
	return ls.repo.IncrementLike(locationID)
}

func (ls *LocationService) GetLeaderboard(page, pageSize int) ([]models.Location, error) {
	return ls.repo.GetLeaderboard(page, pageSize)
}

func (ls *LocationService) GetAllLikes() ([]models.Location, error) {
	return ls.repo.GetAllLikes()
}

================
File: backend/internal/utils/geo.go
================
package utils

import "math"

// GridSize defines the grid spacing in degrees
const GridSize = 0.02

func ToGridLocation(lat, lng float64) (float64, float64) {
    gridLat := math.Floor(lat/GridSize) * GridSize
    gridLng := math.Floor(lng/GridSize) * GridSize
    return gridLat, gridLng
}

================
File: backend/internal/utils/logger.go
================
package utils

import "log"

// Simple wrapper around log, could integrate with Datadog logs or other logging frameworks
func Info(msg string) {
    log.Println("[INFO]", msg)
}

func Error(msg string) {
    log.Println("[ERROR]", msg)
}

================
File: backend/scripts/init_redis.go
================
package main

import (
	"context"
	"encoding/json"
	"flag"
	"fmt"
	"log"
	"os"
	"path/filepath"

	"github.com/redis/go-redis/v9"
)

type Location struct {
	LocationID  string  `json:"location_id"`
	Latitude    float64 `json:"latitude"`
	Longitude   float64 `json:"longitude"`
	Likes       int     `json:"likes"`
	Description string  `json:"description"`
}

// 从JSON文件加载位置数据
func loadLocationsFromFile(filePath string) ([]Location, error) {
	data, err := os.ReadFile(filePath)
	if err != nil {
		return nil, fmt.Errorf("读取数据文件失败: %w", err)
	}

	var locations []Location
	if err := json.Unmarshal(data, &locations); err != nil {
		return nil, fmt.Errorf("解析JSON数据失败: %w", err)
	}

	return locations, nil
}

func main() {
	// 命令行参数
	redisAddr := flag.String("redis", "", "Redis地址 (例如: localhost:6379)")
	dataFile := flag.String("data", "", "位置数据JSON文件路径")
	flag.Parse()

	// 如果未指定Redis地址，尝试从环境变量获取
	if *redisAddr == "" {
		*redisAddr = os.Getenv("REDIS_ADDRESS")
		if *redisAddr == "" {
			*redisAddr = "localhost:6379" // 默认地址
		}
	}

	// 如果未指定数据文件，使用默认路径
	if *dataFile == "" {
		*dataFile = filepath.Join("data", "locations.json")
	}

	// 加载位置数据
	locations, err := loadLocationsFromFile(*dataFile)
	if err != nil {
		log.Fatalf("加载位置数据失败: %v", err)
	}

	// 连接Redis
	rdb := redis.NewClient(&redis.Options{
		Addr: *redisAddr,
		DB:   0,
	})

	ctx := context.Background()

	// 测试连接
	if err := rdb.Ping(ctx).Err(); err != nil {
		log.Fatalf("Redis连接失败: %v", err)
	}

	log.Printf("成功连接到Redis: %s", *redisAddr)

	// 清理现有数据
	if err := rdb.FlushDB(ctx).Err(); err != nil {
		log.Fatalf("清理数据库失败: %v", err)
	}

	// 添加位置数据
	for _, loc := range locations {
		// 将位置ID添加到位置集合
		if err := rdb.SAdd(ctx, "locations", loc.LocationID).Err(); err != nil {
			log.Printf("添加位置ID失败 %s: %v", loc.LocationID, err)
			continue
		}

		// 存储位置详情
		locJSON, _ := json.Marshal(loc)
		if err := rdb.HSet(ctx,
			fmt.Sprintf("location:%s", loc.LocationID),
			"data", string(locJSON),
			"likes", loc.Likes,
		).Err(); err != nil {
			log.Printf("存储位置详情失败 %s: %v", loc.LocationID, err)
		}

		// 存储位置描述
		if loc.Description != "" {
			if err := rdb.HSet(ctx,
				fmt.Sprintf("ai_description:%s", loc.LocationID),
				"desc", loc.Description,
			).Err(); err != nil {
				log.Printf("存储位置描述失败 %s: %v", loc.LocationID, err)
			}
		}

		// 更新点赞排行榜
		if err := rdb.ZAdd(ctx, "location_likes", redis.Z{
			Score:  float64(loc.Likes),
			Member: loc.LocationID,
		}).Err(); err != nil {
			log.Printf("更新排行榜失败 %s: %v", loc.LocationID, err)
		}
	}

	log.Printf("成功初始化 %d 个位置数据", len(locations))
}

================
File: backend/scripts/init_redis.sh
================
#!/bin/bash

# 获取脚本所在目录的绝对路径
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"

# 默认值
REDIS_ADDR=${REDIS_ADDRESS:-"localhost:6379"}
DATA_FILE="$PROJECT_ROOT/data/locations.json"

# 编译并运行初始化程序
cd "$PROJECT_ROOT" && go run scripts/init_redis.go -redis="$REDIS_ADDR" -data="$DATA_FILE"

================
File: backend/docker-compose.yml
================
version: '3.8'

services:
  redis:
    image: redis:latest
    container_name: streetview-redis
    ports:
      - "6379:6379"
    volumes:
      - redis-data:/data
    command: redis-server --appendonly yes
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 5s
      timeout: 3s
      retries: 3

volumes:
  redis-data:

================
File: backend/go.mod
================
module github.com/my-streetview-project/backend

go 1.22.2

require (
	github.com/gin-gonic/gin v1.10.0
	github.com/redis/go-redis/v9 v9.7.0
)

require (
	github.com/bytedance/sonic v1.11.6 // indirect
	github.com/bytedance/sonic/loader v0.1.1 // indirect
	github.com/cespare/xxhash/v2 v2.2.0 // indirect
	github.com/cloudwego/base64x v0.1.4 // indirect
	github.com/cloudwego/iasm v0.2.0 // indirect
	github.com/dgryski/go-rendezvous v0.0.0-20200823014737-9f7001d12a5f // indirect
	github.com/gabriel-vasile/mimetype v1.4.3 // indirect
	github.com/gin-contrib/sse v0.1.0 // indirect
	github.com/go-playground/locales v0.14.1 // indirect
	github.com/go-playground/universal-translator v0.18.1 // indirect
	github.com/go-playground/validator/v10 v10.20.0 // indirect
	github.com/goccy/go-json v0.10.2 // indirect
	github.com/joho/godotenv v1.5.1 // indirect
	github.com/json-iterator/go v1.1.12 // indirect
	github.com/klauspost/cpuid/v2 v2.2.7 // indirect
	github.com/leodido/go-urn v1.4.0 // indirect
	github.com/mattn/go-isatty v0.0.20 // indirect
	github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd // indirect
	github.com/modern-go/reflect2 v1.0.2 // indirect
	github.com/pelletier/go-toml/v2 v2.2.2 // indirect
	github.com/twitchyliquid64/golang-asm v0.15.1 // indirect
	github.com/ugorji/go/codec v1.2.12 // indirect
	golang.org/x/arch v0.8.0 // indirect
	golang.org/x/crypto v0.23.0 // indirect
	golang.org/x/net v0.25.0 // indirect
	golang.org/x/sys v0.20.0 // indirect
	golang.org/x/text v0.15.0 // indirect
	google.golang.org/protobuf v1.34.1 // indirect
	gopkg.in/yaml.v3 v3.0.1 // indirect
)

================
File: backend/go.sum
================
github.com/bsm/ginkgo/v2 v2.12.0 h1:Ny8MWAHyOepLGlLKYmXG4IEkioBysk6GpaRTLC8zwWs=
github.com/bsm/ginkgo/v2 v2.12.0/go.mod h1:SwYbGRRDovPVboqFv0tPTcG1sN61LM1Z4ARdbAV9g4c=
github.com/bsm/gomega v1.27.10 h1:yeMWxP2pV2fG3FgAODIY8EiRE3dy0aeFYt4l7wh6yKA=
github.com/bsm/gomega v1.27.10/go.mod h1:JyEr/xRbxbtgWNi8tIEVPUYZ5Dzef52k01W3YH0H+O0=
github.com/bytedance/sonic v1.11.6 h1:oUp34TzMlL+OY1OUWxHqsdkgC/Zfc85zGqw9siXjrc0=
github.com/bytedance/sonic v1.11.6/go.mod h1:LysEHSvpvDySVdC2f87zGWf6CIKJcAvqab1ZaiQtds4=
github.com/bytedance/sonic/loader v0.1.1 h1:c+e5Pt1k/cy5wMveRDyk2X4B9hF4g7an8N3zCYjJFNM=
github.com/bytedance/sonic/loader v0.1.1/go.mod h1:ncP89zfokxS5LZrJxl5z0UJcsk4M4yY2JpfqGeCtNLU=
github.com/cespare/xxhash/v2 v2.2.0 h1:DC2CZ1Ep5Y4k3ZQ899DldepgrayRUGE6BBZ/cd9Cj44=
github.com/cespare/xxhash/v2 v2.2.0/go.mod h1:VGX0DQ3Q6kWi7AoAeZDth3/j3BFtOZR5XLFGgcrjCOs=
github.com/cloudwego/base64x v0.1.4 h1:jwCgWpFanWmN8xoIUHa2rtzmkd5J2plF/dnLS6Xd/0Y=
github.com/cloudwego/base64x v0.1.4/go.mod h1:0zlkT4Wn5C6NdauXdJRhSKRlJvmclQ1hhJgA0rcu/8w=
github.com/cloudwego/iasm v0.2.0 h1:1KNIy1I1H9hNNFEEH3DVnI4UujN+1zjpuk6gwHLTssg=
github.com/cloudwego/iasm v0.2.0/go.mod h1:8rXZaNYT2n95jn+zTI1sDr+IgcD2GVs0nlbbQPiEFhY=
github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=
github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/dgryski/go-rendezvous v0.0.0-20200823014737-9f7001d12a5f h1:lO4WD4F/rVNCu3HqELle0jiPLLBs70cWOduZpkS1E78=
github.com/dgryski/go-rendezvous v0.0.0-20200823014737-9f7001d12a5f/go.mod h1:cuUVRXasLTGF7a8hSLbxyZXjz+1KgoB3wDUb6vlszIc=
github.com/gabriel-vasile/mimetype v1.4.3 h1:in2uUcidCuFcDKtdcBxlR0rJ1+fsokWf+uqxgUFjbI0=
github.com/gabriel-vasile/mimetype v1.4.3/go.mod h1:d8uq/6HKRL6CGdk+aubisF/M5GcPfT7nKyLpA0lbSSk=
github.com/gin-contrib/sse v0.1.0 h1:Y/yl/+YNO8GZSjAhjMsSuLt29uWRFHdHYUb5lYOV9qE=
github.com/gin-contrib/sse v0.1.0/go.mod h1:RHrZQHXnP2xjPF+u1gW/2HnVO7nvIa9PG3Gm+fLHvGI=
github.com/gin-gonic/gin v1.10.0 h1:nTuyha1TYqgedzytsKYqna+DfLos46nTv2ygFy86HFU=
github.com/gin-gonic/gin v1.10.0/go.mod h1:4PMNQiOhvDRa013RKVbsiNwoyezlm2rm0uX/T7kzp5Y=
github.com/go-playground/assert/v2 v2.2.0 h1:JvknZsQTYeFEAhQwI4qEt9cyV5ONwRHC+lYKSsYSR8s=
github.com/go-playground/assert/v2 v2.2.0/go.mod h1:VDjEfimB/XKnb+ZQfWdccd7VUvScMdVu0Titje2rxJ4=
github.com/go-playground/locales v0.14.1 h1:EWaQ/wswjilfKLTECiXz7Rh+3BjFhfDFKv/oXslEjJA=
github.com/go-playground/locales v0.14.1/go.mod h1:hxrqLVvrK65+Rwrd5Fc6F2O76J/NuW9t0sjnWqG1slY=
github.com/go-playground/universal-translator v0.18.1 h1:Bcnm0ZwsGyWbCzImXv+pAJnYK9S473LQFuzCbDbfSFY=
github.com/go-playground/universal-translator v0.18.1/go.mod h1:xekY+UJKNuX9WP91TpwSH2VMlDf28Uj24BCp08ZFTUY=
github.com/go-playground/validator/v10 v10.20.0 h1:K9ISHbSaI0lyB2eWMPJo+kOS/FBExVwjEviJTixqxL8=
github.com/go-playground/validator/v10 v10.20.0/go.mod h1:dbuPbCMFw/DrkbEynArYaCwl3amGuJotoKCe95atGMM=
github.com/goccy/go-json v0.10.2 h1:CrxCmQqYDkv1z7lO7Wbh2HN93uovUHgrECaO5ZrCXAU=
github.com/goccy/go-json v0.10.2/go.mod h1:6MelG93GURQebXPDq3khkgXZkazVtN9CRI+MGFi0w8I=
github.com/google/go-cmp v0.5.5 h1:Khx7svrCpmxxtHBq5j2mp/xVjsi8hQMfNLvJFAlrGgU=
github.com/google/go-cmp v0.5.5/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=
github.com/google/gofuzz v1.0.0/go.mod h1:dBl0BpW6vV/+mYPU4Po3pmUjxk6FQPldtuIdl/M65Eg=
github.com/joho/godotenv v1.5.1 h1:7eLL/+HRGLY0ldzfGMeQkb7vMd0as4CfYvUVzLqw0N0=
github.com/joho/godotenv v1.5.1/go.mod h1:f4LDr5Voq0i2e/R5DDNOoa2zzDfwtkZa6DnEwAbqwq4=
github.com/json-iterator/go v1.1.12 h1:PV8peI4a0ysnczrg+LtxykD8LfKY9ML6u2jnxaEnrnM=
github.com/json-iterator/go v1.1.12/go.mod h1:e30LSqwooZae/UwlEbR2852Gd8hjQvJoHmT4TnhNGBo=
github.com/klauspost/cpuid/v2 v2.0.9/go.mod h1:FInQzS24/EEf25PyTYn52gqo7WaD8xa0213Md/qVLRg=
github.com/klauspost/cpuid/v2 v2.2.7 h1:ZWSB3igEs+d0qvnxR/ZBzXVmxkgt8DdzP6m9pfuVLDM=
github.com/klauspost/cpuid/v2 v2.2.7/go.mod h1:Lcz8mBdAVJIBVzewtcLocK12l3Y+JytZYpaMropDUws=
github.com/knz/go-libedit v1.10.1/go.mod h1:MZTVkCWyz0oBc7JOWP3wNAzd002ZbM/5hgShxwh4x8M=
github.com/leodido/go-urn v1.4.0 h1:WT9HwE9SGECu3lg4d/dIA+jxlljEa1/ffXKmRjqdmIQ=
github.com/leodido/go-urn v1.4.0/go.mod h1:bvxc+MVxLKB4z00jd1z+Dvzr47oO32F/QSNjSBOlFxI=
github.com/mattn/go-isatty v0.0.20 h1:xfD0iDuEKnDkl03q4limB+vH+GxLEtL/jb4xVJSWWEY=
github.com/mattn/go-isatty v0.0.20/go.mod h1:W+V8PltTTMOvKvAeJH7IuucS94S2C6jfK/D7dTCTo3Y=
github.com/modern-go/concurrent v0.0.0-20180228061459-e0a39a4cb421/go.mod h1:6dJC0mAP4ikYIbvyc7fijjWJddQyLn8Ig3JB5CqoB9Q=
github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd h1:TRLaZ9cD/w8PVh93nsPXa1VrQ6jlwL5oN8l14QlcNfg=
github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd/go.mod h1:6dJC0mAP4ikYIbvyc7fijjWJddQyLn8Ig3JB5CqoB9Q=
github.com/modern-go/reflect2 v1.0.2 h1:xBagoLtFs94CBntxluKeaWgTMpvLxC4ur3nMaC9Gz0M=
github.com/modern-go/reflect2 v1.0.2/go.mod h1:yWuevngMOJpCy52FWWMvUC8ws7m/LJsjYzDa0/r8luk=
github.com/pelletier/go-toml/v2 v2.2.2 h1:aYUidT7k73Pcl9nb2gScu7NSrKCSHIDE89b3+6Wq+LM=
github.com/pelletier/go-toml/v2 v2.2.2/go.mod h1:1t835xjRzz80PqgE6HHgN2JOsmgYu/h4qDAS4n929Rs=
github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=
github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
github.com/redis/go-redis/v9 v9.7.0 h1:HhLSs+B6O021gwzl+locl0zEDnyNkxMtf/Z3NNBMa9E=
github.com/redis/go-redis/v9 v9.7.0/go.mod h1:f6zhXITC7JUJIlPEiBOTXxJgPLdZcA93GewI7inzyWw=
github.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=
github.com/stretchr/objx v0.4.0/go.mod h1:YvHI0jy2hoMjB+UWwv71VJQ9isScKT/TqJzVSSt89Yw=
github.com/stretchr/objx v0.5.0/go.mod h1:Yh+to48EsGEfYuaHDzXPcE3xhTkx73EhmCGUpEOglKo=
github.com/stretchr/objx v0.5.2/go.mod h1:FRsXN1f5AsAjCGJKqEizvkpNtU+EGNCLh3NxZ/8L+MA=
github.com/stretchr/testify v1.3.0/go.mod h1:M5WIy9Dh21IEIfnGCwXGc5bZfKNJtfHm1UVUgZn+9EI=
github.com/stretchr/testify v1.7.0/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=
github.com/stretchr/testify v1.7.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=
github.com/stretchr/testify v1.8.0/go.mod h1:yNjHg4UonilssWZ8iaSj1OCr/vHnekPRkoO+kdMU+MU=
github.com/stretchr/testify v1.8.1/go.mod h1:w2LPCIKwWwSfY2zedu0+kehJoqGctiVI29o6fzry7u4=
github.com/stretchr/testify v1.8.4/go.mod h1:sz/lmYIOXD/1dqDmKjjqLyZ2RngseejIcXlSw2iwfAo=
github.com/stretchr/testify v1.9.0 h1:HtqpIVDClZ4nwg75+f6Lvsy/wHu+3BoSGCbBAcpTsTg=
github.com/stretchr/testify v1.9.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=
github.com/twitchyliquid64/golang-asm v0.15.1 h1:SU5vSMR7hnwNxj24w34ZyCi/FmDZTkS4MhqMhdFk5YI=
github.com/twitchyliquid64/golang-asm v0.15.1/go.mod h1:a1lVb/DtPvCB8fslRZhAngC2+aY1QWCk3Cedj/Gdt08=
github.com/ugorji/go/codec v1.2.12 h1:9LC83zGrHhuUA9l16C9AHXAqEV/2wBQ4nkvumAE65EE=
github.com/ugorji/go/codec v1.2.12/go.mod h1:UNopzCgEMSXjBc6AOMqYvWC1ktqTAfzJZUZgYf6w6lg=
golang.org/x/arch v0.0.0-20210923205945-b76863e36670/go.mod h1:5om86z9Hs0C8fWVUuoMHwpExlXzs5Tkyp9hOrfG7pp8=
golang.org/x/arch v0.8.0 h1:3wRIsP3pM4yUptoR96otTUOXI367OS0+c9eeRi9doIc=
golang.org/x/arch v0.8.0/go.mod h1:FEVrYAQjsQXMVJ1nsMoVVXPZg6p2JE2mx8psSWTDQys=
golang.org/x/crypto v0.23.0 h1:dIJU/v2J8Mdglj/8rJ6UUOM3Zc9zLZxVZwwxMooUSAI=
golang.org/x/crypto v0.23.0/go.mod h1:CKFgDieR+mRhux2Lsu27y0fO304Db0wZe70UKqHu0v8=
golang.org/x/net v0.25.0 h1:d/OCCoBEUq33pjydKrGQhw7IlUPI2Oylr+8qLx49kac=
golang.org/x/net v0.25.0/go.mod h1:JkAGAh7GEvH74S6FOH42FLoXpXbE/aqXSrIQjXgsiwM=
golang.org/x/sys v0.5.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.20.0 h1:Od9JTbYCk261bKm4M/mw7AklTlFYIa0bIp9BgSm1S8Y=
golang.org/x/sys v0.20.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=
golang.org/x/text v0.15.0 h1:h1V/4gjBv8v9cjcR6+AR5+/cIYK5N/WAgiv4xlsEtAk=
golang.org/x/text v0.15.0/go.mod h1:18ZOQIKpY8NJVqYksKHtTdi31H5itFRjB5/qKTNYzSU=
golang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543 h1:E7g+9GITq07hpfrRu66IVDexMakfv52eLZ2CXBWiKr4=
golang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
google.golang.org/protobuf v1.34.1 h1:9ddQBjfCyZPOHPUiPxpYESBLc+T8P3E+Vo4IbKZgFWg=
google.golang.org/protobuf v1.34.1/go.mod h1:c6P6GXX6sHbq/GpV6MGZEdwhWPcYBgnhAHhKbcUYpos=
gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405 h1:yhCVgyC4o1eVCa2tZl7eS0r+SDo693bJlVdllGtEeKM=
gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
gopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=
gopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
nullprogram.com/x/optparse v1.0.0/go.mod h1:KdyPE+Igbe0jQUrVfMqDMeJQIJZEuyV7pjYmp6pbG50=
rsc.io/pdf v0.1.1/go.mod h1:n8OzWcQ6Sp37PL01nO98y4iUCRdTGarVfzxY20ICaU4=

================
File: backend/Makefile
================
.PHONY: init-redis
init-redis:
	@echo "初始化 Redis 数据..."
	@./scripts/init_redis.sh

.PHONY: dev-init-redis
dev-init-redis:
	@echo "初始化开发环境 Redis 数据..."
	@REDIS_ADDRESS=localhost:6379 ./scripts/init_redis.sh 

.PHONY: docker-redis-start
docker-redis-start:
	@echo "启动 Redis Docker 容器..."
	@docker-compose up -d redis
	@echo "等待 Redis 就绪..."
	@sleep 3

.PHONY: docker-redis-stop
docker-redis-stop:
	@echo "停止 Redis Docker 容器..."
	@docker-compose down

.PHONY: docker-redis-logs
docker-redis-logs:
	@docker-compose logs -f redis

.PHONY: docker-redis-clean
docker-redis-clean:
	@echo "清理 Redis 数据..."
	@docker-compose down -v

.PHONY: dev-setup
dev-setup: docker-redis-start init-redis
	@echo "开发环境设置完成"

================
File: frontend/public/index.html
================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval' https://*.googleapis.com https://*.gstatic.com; style-src 'self' 'unsafe-inline' https://*.googleapis.com; img-src 'self' data: https://*.googleapis.com https://*.gstatic.com https://*.ggpht.com; connect-src 'self' http://localhost:8080 https://*.googleapis.com https://streetviewpublish.googleapis.com; font-src 'self' https://*.gstatic.com;">
    <title>Street View Project</title>
</head>
<body>
    <div id="root"></div>
</body>
</html>

================
File: frontend/src/components/LeaderboardList.jsx
================
import React from 'react';

export default function LeaderboardList({ data }) {
    return (
        <div style={{ maxHeight: '400px', overflowY: 'auto' }}>
            <table style={{ width: '100%', borderCollapse: 'collapse' }}>
                <thead style={{ position: 'sticky', top: 0, background: 'white' }}>
                    <tr>
                        <th style={styles.th}>排名</th>
                        <th style={styles.th}>位置</th>
                        <th style={styles.th}>点赞数</th>
                    </tr>
                </thead>
                <tbody>
                    {data.map((item, index) => (
                        <tr key={item.location_id}>
                            <td style={styles.td}>{index + 1}</td>
                            <td style={styles.td}>
                                {item.latitude.toFixed(4)}, {item.longitude.toFixed(4)}
                            </td>
                            <td style={styles.td}>{item.likes}</td>
                        </tr>
                    ))}
                </tbody>
            </table>
        </div>
    );
}

const styles = {
    th: {
        padding: '8px',
        borderBottom: '2px solid #ddd',
        textAlign: 'left',
    },
    td: {
        padding: '8px',
        borderBottom: '1px solid #ddd',
    }
};

================
File: frontend/src/components/MapView.jsx
================
import React, { useEffect, useRef, useState } from 'react';

export default function MapView({ locations }) {
    const ref = useRef(null);
    const [error, setError] = useState(null);
    const [isLoaded, setIsLoaded] = useState(false);

    useEffect(() => {
        if (!window.google) {
            setError('Google Maps API未加载');
            return;
        }

        try {
            const map = new window.google.maps.Map(ref.current, {
                center: { lat: 0, lng: 0 },
                zoom: 2,
                minZoom: 2, // 限制最小缩放级别
                maxZoom: 18,
                mapTypeControl: true,
                fullscreenControl: true,
            });

            // 清除旧的标记
            const markers = [];
            locations.forEach(loc => {
                const marker = new window.google.maps.Marker({
                    position: { lat: loc.latitude, lng: loc.longitude },
                    map: map,
                    title: `点赞数: ${loc.likes}`
                });
                markers.push(marker);
            });

            setIsLoaded(true);
        } catch (err) {
            setError('地图加载失败');
            console.error(err);
        }
    }, [locations]);

    if (error) {
        return <div style={{ width: '600px', height: '400px', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
            错误: {error}
        </div>;
    }

    if (!isLoaded) {
        return <div style={{ width: '600px', height: '400px', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
            加载中...
        </div>;
    }

    return <div style={{ width: '600px', height: '400px' }} ref={ref}></div>;
}

================
File: frontend/src/components/StreetView.jsx
================
import React, { useEffect, useRef, useState } from 'react';

// 在组件外部维护一个加载状态
let googleMapsPromise = null;

function loadGoogleMapsScript() {
    if (googleMapsPromise) {
        return googleMapsPromise;
    }

    googleMapsPromise = new Promise((resolve, reject) => {
        if (window.google && window.google.maps) {
            console.log('Google Maps 已经加载，直接使用');
            resolve(window.google.maps);
            return;
        }

        // 检查是否已经有script标签
        const existingScript = document.querySelector('script[src*="maps.googleapis.com/maps/api/js"]');
        if (existingScript) {
            console.log('发现已存在的 Google Maps 脚本标签');
            // 如果已经有script标签，等待它加载完成
            existingScript.addEventListener('load', () => {
                if (window.google && window.google.maps) {
                    resolve(window.google.maps);
                } else {
                    reject(new Error('Google Maps 加载失败'));
                }
            });
            existingScript.addEventListener('error', () => {
                reject(new Error('Google Maps 加载失败'));
            });
            return;
        }

        console.log('创建新的 Google Maps 脚本标签');
        const script = document.createElement('script');
        script.src = `https://maps.googleapis.com/maps/api/js?key=${process.env.REACT_APP_GOOGLE_MAPS_API_KEY}`;
        script.async = true;
        script.defer = true;
        script.onerror = (e) => {
            console.error('Google Maps 脚本加载失败:', e);
            googleMapsPromise = null;
            reject(new Error('Google Maps 加载失败'));
        };
        script.onload = () => {
            console.log('Google Maps 脚本加载完成');
            if (window.google && window.google.maps) {
                resolve(window.google.maps);
            } else {
                console.error('Google Maps API 未能正确初始化');
                googleMapsPromise = null;
                reject(new Error('Google Maps 加载失败'));
            }
        };
        document.head.appendChild(script);
    });

    return googleMapsPromise;
}

export default function StreetView({ latitude, longitude }) {
    // 验证位置是否有效
    const isValidLocation = typeof latitude === 'number' && 
                          typeof longitude === 'number' && 
                          !isNaN(latitude) && 
                          !isNaN(longitude) && 
                          latitude !== 0 && 
                          longitude !== 0;

    console.log('StreetView 组件渲染，位置:', { latitude, longitude, isValidLocation });

    const mapRef = useRef(null);
    const panoRef = useRef(null);
    const [error, setError] = useState(null);
    const [isLoaded, setIsLoaded] = useState(false);
    const [maps, setMaps] = useState(null);
    const [isInitialized, setIsInitialized] = useState(false);

    // 重置初始化状态当位置改变时
    useEffect(() => {
        if (isInitialized) {
            console.log('位置改变，重置初始化状态');
            setIsInitialized(false);
            setIsLoaded(false);
            setError(null);
        }
    }, [latitude, longitude]);

    // 加载 Google Maps API
    useEffect(() => {
        console.log('加载 Maps API useEffect 触发');
        let isMounted = true;

        const loadMaps = async () => {
            if (!isValidLocation) {
                console.log('位置无效，跳过加载');
                return;
            }

            try {
                console.log('开始加载 Google Maps API');
                const mapsInstance = await loadGoogleMapsScript();
                console.log('Google Maps API 加载成功');
                if (isMounted) {
                    setMaps(mapsInstance);
                }
            } catch (err) {
                console.error('加载 Google Maps API 时出错:', err);
                if (isMounted) {
                    setError('Google Maps API 加载失败: ' + err.message);
                }
            }
        };

        if (!maps) {
            loadMaps();
        } else {
            console.log('Maps API 已加载，跳过');
        }

        return () => {
            console.log('Maps API useEffect 清理');
            isMounted = false;
        };
    }, [isValidLocation]);

    // 初始化地图和街景
    useEffect(() => {
        console.log('初始化 useEffect 触发，状态:', {
            hasMaps: !!maps,
            hasMapRef: !!mapRef.current,
            hasPanoRef: !!panoRef.current,
            isInitialized,
            isValidLocation
        });

        if (!maps || !mapRef.current || !panoRef.current || isInitialized || !isValidLocation) {
            return;
        }

        let isMounted = true;
        console.log('开始初始化地图和街景视图');

        try {
            const position = { lat: latitude, lng: longitude };
            console.log('使用位置:', position);

            // 创建地图实例
            const map = new maps.Map(mapRef.current, {
                center: position,
                zoom: 14,
                fullscreenControl: false,
                streetViewControl: false
            });
            console.log('地图实例创建成功');

            // 创建街景实例
            const panorama = new maps.StreetViewPanorama(panoRef.current, {
                position: position,
                pov: {
                    heading: 34,
                    pitch: 10
                },
                fullscreenControl: false,
                showRoadLabels: false,
                motionTracking: false
            });
            console.log('街景实例创建成功');

            // 将地图和街景关联
            map.setStreetView(panorama);
            console.log('地图和街景关联成功');

            // 检查街景是否可用
            const service = new maps.StreetViewService();
            service.getPanorama({ 
                location: position,
                radius: 50,
                source: maps.StreetViewSource.OUTDOOR
            }, (data, status) => {
                if (!isMounted) return;
                
                console.log('街景数据状态:', status);
                if (status === 'OK') {
                    setIsInitialized(true);
                    setIsLoaded(true);
                    setError(null);
                } else {
                    console.error('无法加载街景数据:', status);
                    setError('该位置没有街景数据');
                    setIsLoaded(true);
                }
            });
        } catch (err) {
            console.error('初始化地图和街景时出错:', err);
            if (isMounted) {
                setError('初始化失败: ' + err.message);
                setIsLoaded(true);
            }
        }

        return () => {
            console.log('初始化 useEffect 清理');
            isMounted = false;
        };
    }, [maps, latitude, longitude, isInitialized, isValidLocation]);

    if (!isValidLocation) {
        return (
            <div style={{ 
                width: '100%',
                height: '400px',
                display: 'flex', 
                alignItems: 'center', 
                justifyContent: 'center', 
                border: '1px solid #ccc',
                backgroundColor: '#f5f5f5',
                flexDirection: 'column',
                padding: '20px',
                textAlign: 'center'
            }}>
                <div>等待位置数据...</div>
            </div>
        );
    }

    // 始终渲染容器，即使在加载状态下
    return (
        <div style={{ display: 'flex', width: '100%', height: '400px', gap: '10px' }}>
            <div 
                ref={mapRef} 
                style={{ 
                    flex: 1,
                    border: '1px solid #ccc'
                }} 
            />
            <div 
                ref={panoRef} 
                style={{ 
                    flex: 1,
                    border: '1px solid #ccc'
                }} 
            />
            {(error || !isLoaded) && (
                <div style={{ 
                    position: 'absolute',
                    top: 0,
                    left: 0,
                    right: 0,
                    bottom: 0,
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    backgroundColor: 'rgba(245, 245, 245, 0.9)',
                    flexDirection: 'column',
                    padding: '20px',
                    textAlign: 'center'
                }}>
                    <div>{error || '加载中...'}</div>
                    <div style={{ marginTop: '10px', fontSize: '14px', color: '#666' }}>
                        位置: {latitude}, {longitude}
                    </div>
                </div>
            )}
        </div>
    );
}

================
File: frontend/src/pages/HomePage.jsx
================
import React, { useState, useEffect, useRef } from 'react';
import StreetView from '../components/StreetView';
import { getRandomLocation, likeLocation, getLocationDescription } from '../services/api';

// 测试用的坐标点
/*
const TEST_LOCATIONS = [
    {
        location_id: 'test_001',
        latitude: 35.6762,  // 东京涩谷十字路口
        longitude: 139.6503,
        likes: 0,
        description: "测试位置：东京涩谷十字路口"
    },
    {
        location_id: 'test_002',
        latitude: 48.8584,  // 巴黎埃菲尔铁塔
        longitude: 2.2945,
        likes: 0,
        description: "测试位置：巴黎埃菲尔铁塔"
    },
    {
        location_id: 'test_003',
        latitude: 40.7580,  // 纽约时代广场
        longitude: -73.9855,
        likes: 0,
        description: "测试位置：纽约时代广场"
    }
];
*/

export default function HomePage() {
    const [data, setData] = useState(null);
    const [error, setError] = useState(null);
    const [isLoading, setIsLoading] = useState(false);
    const [locationDesc, setLocationDesc] = useState('');
    const [isLoadingDesc, setIsLoadingDesc] = useState(false);
    const loadingRef = useRef(false);

    const loadRandomLocation = async () => {
        if (loadingRef.current) return;
        
        try {
            loadingRef.current = true;
            setIsLoading(true);
            const resp = await getRandomLocation();
            if (resp.success) {
                setData(resp.data);
                setError(null);
            } else {
                setError(resp.error || '加载失败');
            }
        } catch (err) {
            setError('网络请求失败');
            console.error(err);
        } finally {
            setIsLoading(false);
            loadingRef.current = false;
        }
    };

    const loadLocationDescription = async () => {
        if (!data || isLoadingDesc) return;
        try {
            setIsLoadingDesc(true);
            const resp = await getLocationDescription(data.location_id);
            if (resp.success) {
                setLocationDesc(resp.data.description);
            } else {
                console.error('获取位置描述失败:', resp.error);
            }
        } catch (err) {
            console.error('获取位置描述出错:', err);
        } finally {
            setIsLoadingDesc(false);
        }
    };

    useEffect(() => {
        loadRandomLocation();
        return () => {
            loadingRef.current = false;
        };
    }, []);

    useEffect(() => {
        if (data?.location_id && !isLoadingDesc) {
            setLocationDesc(''); // 清空旧的位置描述
            loadLocationDescription();
        }
    }, [data?.location_id]);

    const handleLike = async () => {
        if (!data) return;
        try {
            const resp = await likeLocation(data.location_id);
            if (resp.success) {
                setData({ ...data, likes: resp.data.likes });
            } else {
                alert('点赞失败: ' + (resp.error || '未知错误'));
            }
        } catch (err) {
            alert('网络请求失败');
            console.error(err);
        }
    };

    const handleShare = () => {
        if (!data) return;
        const url = window.location.origin + `/?loc=${encodeURIComponent(data.location_id)}`;
        navigator.clipboard.writeText(url).then(() => {
            alert("链接已复制到剪贴板!");
        }).catch(() => {
            alert("复制失败,请手动复制: " + url);
        });
    };

    const handleRefresh = () => {
        if (!loadingRef.current) {
            loadRandomLocation();
        }
    };

    if (error) {
        return <div>
            <h2>出错了</h2>
            <p>{error}</p>
            <button onClick={handleRefresh}>重试</button>
        </div>;
    }

    if (isLoading || !data) {
        return <div>加载中...</div>;
    }

    return (
        <div>
            <h2>随机街景</h2>
            <StreetView latitude={data.latitude} longitude={data.longitude} />
            <div>
                <h3>位置描述：</h3>
                {isLoadingDesc ? (
                    <p>正在获取位置描述...</p>
                ) : locationDesc ? (
                    <p>{locationDesc}</p>
                ) : (
                    <button onClick={loadLocationDescription}>获取位置描述</button>
                )}
            </div>
            <p>点赞数: {data.likes}</p>
            <button onClick={handleLike}>点赞</button>
            <button onClick={handleShare}>分享</button>
            <button onClick={handleRefresh}>换一个</button>
        </div>
    );
}

================
File: frontend/src/pages/MapAndLeaderboardPage.jsx
================
import React, { useState, useEffect } from 'react';
import MapView from '../components/MapView';
import LeaderboardList from '../components/LeaderboardList';
import { getMapLikes, getLeaderboard } from '../services/api';

export default function MapAndLeaderboardPage() {
    const [mapData, setMapData] = useState([]);
    const [leaderboardData, setLeaderboardData] = useState([]);

    useEffect(() => {
        // 获取地图数据
        (async () => {
            const mapResp = await getMapLikes();
            if (mapResp.success) {
                setMapData(mapResp.data);
            }
        })();

        // 获取排行榜数据
        (async () => {
            const leaderResp = await getLeaderboard();
            if (leaderResp.success) {
                setLeaderboardData(leaderResp.data);
            }
        })();
    }, []);

    return (
        <div>
            <h2>全球热门街景</h2>
            <div style={{ display: 'flex', gap: '20px' }}>
                <div style={{ flex: 1 }}>
                    <h3>地图分布</h3>
                    <MapView locations={mapData} />
                </div>
                <div style={{ flex: 1 }}>
                    <h3>点赞排行榜</h3>
                    <LeaderboardList data={leaderboardData} />
                </div>
            </div>
        </div>
    );
}

================
File: frontend/src/services/api.js
================
// Basic API wrappers to call backend
// Assuming backend runs on same origin or set proper baseURL.

const BASE_URL = process.env.REACT_APP_API_BASE_URL || '';

export async function getRandomLocation() {
    const resp = await fetch(`${BASE_URL}/random-location`, {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({})
    });
    return resp.json();
}

export async function likeLocation(location_id) {
    const resp = await fetch(`${BASE_URL}/like`, {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({ location_id })
    });
    return resp.json();
}

export async function getLeaderboard(page = 1, page_size = 10) {
    const resp = await fetch(`${BASE_URL}/leaderboard`, {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({ page, page_size })
    });
    return resp.json();
}

export async function getMapLikes() {
    const resp = await fetch(`${BASE_URL}/map-likes`, {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({})
    });
    return resp.json();
}

export async function getLocationDescription(location_id) {
    const resp = await fetch(`${BASE_URL}/location-description`, {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({ location_id })
    });
    return resp.json();
}

================
File: frontend/src/App.tsx
================
import React from 'react';
import { BrowserRouter as Router, Routes, Route, Link } from 'react-router-dom';
import HomePage from './pages/HomePage';
import MapAndLeaderboardPage from './pages/MapAndLeaderboardPage';

const App: React.FC = () => {
    return (
        <Router>
            <div style={{ padding: '10px' }}>
                <h1>街景浏览器</h1>
                <nav style={{ marginBottom: '10px' }}>
                    <Link to="/">首页</Link> | <Link to="/map">地图与排行榜</Link>
                </nav>
                <Routes>
                    <Route path="/" element={<HomePage />} />
                    <Route path="/map" element={<MapAndLeaderboardPage />} />
                </Routes>
            </div>
        </Router>
    );
}

export default App;

================
File: frontend/src/index.tsx
================
import React from 'react';
import { createRoot } from 'react-dom/client';
import App from './App';

const container = document.getElementById('root');
if (!container) throw new Error('Failed to find the root element');
const root = createRoot(container);
root.render(
  <App />
);

================
File: frontend/package.json
================
{
  "name": "streetview-frontend",
  "version": "1.0.0",
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject",
    "lint": "eslint src --ext .ts,.tsx",
    "format": "prettier --write \"src/**/*.{ts,tsx,css,md}\""
  },
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-router-dom": "^6.20.0",
    "react-scripts": "5.0.1"
  },
  "devDependencies": {
    "@babel/core": "^7.23.3",
    "@babel/preset-react": "^7.23.3",
    "@types/node": "^20.10.0",
    "@types/react": "^18.2.39",
    "@types/react-dom": "^18.2.17",
    "@typescript-eslint/eslint-plugin": "^6.13.1",
    "@typescript-eslint/parser": "^6.13.1",
    "eslint": "^8.54.0",
    "eslint-config-prettier": "^9.0.0",
    "eslint-plugin-react": "^7.33.2",
    "prettier": "^3.1.0",
    "typescript": "^5.3.2"
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}

================
File: frontend/tsconfig.json
================
{
  "compilerOptions": {
    "target": "es5",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noFallthroughCasesInSwitch": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "baseUrl": "src"
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules"]
}

================
File: .gitignore
================
# Dependencies
/frontend/node_modules
/frontend/.pnp
/frontend/.pnp.js

# Testing
/frontend/coverage
/backend/test/coverage

# Production
/frontend/build

# Misc
.DS_Store
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# Logs
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Go
*.exe
*.exe~
*.dll
*.so
*.dylib
*.test
*.out
/backend/tmp

# IDE
.idea/
.vscode/
*.swp
*.swo

# Redis
*.rdb
dump.rdb

# Environment variables
.env

# IDE files
.idea/
.vscode/

# Binaries
bin/
dist/

main

================
File: README.md
================
# 街景展示网站项目文档

## 1 项目整体描述
### 1.1 项目介绍
- 本项目是一个街景展示网站，用户打开即可随机看到来自全球的某个街景。
- 使用AI接口（OpenAI）为当前显示的街景提供历史文化、地理特色及风土人情等描述。
- 用户可对当前街景点赞（无需登录），并可查看全球最受欢迎街景的排行榜。
- 在地图页面，可展示所有用户点赞过的地点分布。
- 为减少精确坐标处理难度和缓存压力，项目将实坐标点映射到约2~3公里网格区域内。

### 1.2 项目目标
- 提升用户浏览全球街景的乐趣和知识性
- 提供热门地点聚合、排行榜和可视化分布
- 确保项目具备可扩展性和可维护性

## 2 系统架构与技术栈
### 2.1 前端
- 使用React框架构建，路由分为首页、排行榜页面和地图页面。
- 首页显示随机街景与AI描述，并提供点赞和分享按钮。
- 前端使用Google Maps/Street View JS API展示街景与全球地图上的点赞分布。
- 通过Fetch或Axios向后端POST JSON请求获取数据。

### 2.2 后端
- 使用Golang及Gin框架实现REST API服务。
- 接口全部使用POST JSON，返回统一响应格式。
- 使用Redis作为缓存与数据存储，不涉及登录与复杂的持久化方案。后期可根据接口抽象替换DB。
- 调用OpenAI API生成地点描述，并缓存结果减少重复调用。
- 用Cloudflare作为CDN与反向代理，提供HTTPS和防护。

## 3 功能与数据处理逻辑
### 3.1 坐标网格化
- 将原始经纬度按0.02度为步长进行取整，作为网格ID。
- 示例：网格大小0.02度约等于2~3公里范围。
- 将网格化坐标拼接成location_id (如"grid:40.7200:-74.0000")。

### 3.2 数据存储结构（Redis）
- locations集合：SET locations，存储所有location_id，随机抽取地点时使用。
- 地点详情：HASH location:<location_id>，字段包含lat, lng, likes。
- AI描述缓存：HASH ai_description:<location_id>，字段desc存描述文本。可设置TTL，如24小时。
- 点赞排行榜：ZSET location_likes，以location_id为member，likes为score。用于快速获取排行榜数据。

### 3.3 API接口
- /random-streetview (POST)
无参数，随机返回一个地点及描述、点赞数。若无描述则调用OpenAI生成并缓存。
- /like (POST)
参数: {"location_id": "xxx"}
对地点点赞+1，返回最新点赞数。更新ZSET与HASH中的likes。
- /leaderboard (POST)
参数: {"page": int, "page_size": int}
返回按点赞数降序排序的地点列表。
- /map-likes (POST)
无参数
返回所有已点赞地点的坐标与likes，用于前端地图显示。
- /ai-description (POST)
参数: {"location_id": "xxx"}
返回地点描述，若无缓存则调用OpenAI生成并缓存。

### 3.4 OpenAI调用策略
- 首次请求描述时调用OpenAI，拼接经纬度信息生成Prompt。
- 返回结果后写入Redis缓存，后续请求相同location_id直接从缓存获取。
- 若OpenAI调用失败则返回错误或默认文本，必要时可在日志中记录。

## 4 性能与缓存优化
- 使用Redis作为高性能数据访问层。
- AI描述有缓存TTL，减少OpenAI频繁调用和成本。
- 排行榜使用Redis ZSET，查询高效，无需额外缓存。
- 前端静态资源通过CDN分发，减少延迟。
- 后端Golang服务轻量高效，对于初期流量足够应对。

## 5 安全与限流策略
- HTTPS访问，Cloudflare作为反向代理和DDoS防护。
- 前后端分离部署时，可在后端设置CORS策略仅允许前端域名。
- 简单限流：在Redis中记录IP请求频率，如某IP一段时间内请求过多则限制。
- 点赞接口可限制同IP或同浏览器的重复过多请求。
- 秘钥管理（如OpenAI API Key）通过环境变量或Secret管理工具，不写死在代码中。

## 6 监控与日志
- 使用Datadog APM与日志收集进行监控。
- 监控指标包括：请求耗时、错误率、Redis状态、OpenAI调用延迟与失败率。
- 日志记录API访问日志、错误日志，方便故障排查。
- 针对OpenAI调用失败或Redis访问异常可设立报警。

## 7 前端实现细节
- React路由划分：
  - "/"：首页，调用/random-streetview获取随机地点并显示街景和描述，提供点赞与分享URL功能。
  - "/leaderboard"：排行榜页面，调用/leaderboard获取数据。
  - "/map"：地图页面，调用/map-likes显示点赞地点在地图上的分布。
- 使用React Hooks管理状态，或使用Redux进行全局状态管理。
- 地图与Street View组件懒加载减少初始加载时间。
- 将后端请求提取到独立的services/api.js文件中，统一管理API调用。

## 8 可扩展性
- 后端存储层通过Repository接口实现，未来可轻松更换为MySQL或PostgreSQL。
- 网格精度可调整，只需修改网格计算逻辑，不影响业务逻辑。
- 可在后期添加用户评论、收藏地点、按国家/城市筛选街景、用户登录等功能。
- 前端组件化设计，易于引入新页面和新功能模块。

## 9 部署与运行指南
### 9.1 环境要求
- 后端：
  - Go 1.22+
  - Redis 7.0+
  - OpenAI API Key
- 前端：
  - Node.js 18+
  - Yarn 或 npm
  - Google Maps API Key

### 9.2 本地开发
#### 后端开发
1. 进入后端目录：
```bash
cd backend
```

2. 设置环境变量：
```bash
export REDIS_ADDRESS=localhost:6379
export OPENAI_API_KEY=your_openai_key
export SERVER_ADDRESS=:8080
```

3. 安装依赖并运行：
```bash
go mod download
go run cmd/server/main.go
```

#### 前端开发
1. 进入前端目录：
```bash
cd frontend
```

2. 创建环境配置文件 `.env.local`：
```
REACT_APP_API_BASE_URL=http://localhost:8080
REACT_APP_GOOGLE_MAPS_API_KEY=your_google_maps_key
```

3. 安装依赖并启动开发服务器：
```bash
yarn install
yarn start
```

### 9.3 生产环境部署
#### 后端部署
1. 编译二进制文件：
```bash
cd backend
CGO_ENABLED=0 GOOS=linux go build -o streetview-server cmd/server/main.go
```

2. 部署到服务器：
```bash
scp streetview-server user@your-server:/path/to/app/
scp .env user@your-server:/path/to/app/
```

3. 在服务器上设置环境变量并运行：
```bash
export REDIS_ADDRESS=localhost:6379
export OPENAI_API_KEY=your_openai_key
export SERVER_ADDRESS=:8080
./streetview-server
```

4. 使用 systemd 管理服务（推荐）：
```bash
# /etc/systemd/system/streetview.service
[Unit]
Description=Street View Service
After=network.target

[Service]
Type=simple
User=streetview
EnvironmentFile=/path/to/app/.env
ExecStart=/path/to/app/streetview-server
Restart=always
RestartSec=5

[Install]
WantedBy=multi-user.target
```

#### 前端部署
1. 构建生产版本：
```bash
cd frontend
yarn build
```

2. 部署到 CDN 或静态托管服务：
```bash
# 例如使用 AWS S3 + CloudFront
aws s3 sync build/ s3://your-bucket-name/
```

3. 配置 Cloudflare（可选）：
   - 添加域名到 Cloudflare
   - 开启 HTTPS
   - 配置页面规则和缓存策略

### 9.4 监控与维护
1. 日志查看：
```bash
# 系统日志
journalctl -u streetview.service

# 应用日志
tail -f /var/log/streetview/app.log
```

2. 性能监控：
   - 使用 Datadog APM 监控应用性能
   - 配置 Redis INFO 监控
   - 设置关键指标报警

3. 数据备份：
```bash
# Redis 备份
redis-cli SAVE
cp /var/lib/redis/dump.rdb /backup/redis/dump.rdb.$(date +%Y%m%d)
```

### 9.5 安全配置
1. 防火墙设置：
```bash
# 只开放必要端口
ufw allow 80/tcp
ufw allow 443/tcp
ufw allow 22/tcp
```

2. SSL 证书：
```bash
# 使用 certbot 获取证书
certbot --nginx -d your-domain.com
```

3. 环境变量管理：
   - 使用 .env 文件存储配置
   - 生产环境使用密钥管理服务
   - 定期轮换 API 密钥

## 10 开发重点与注意事项
- 先实现基础API与Redis交互逻辑，确保随机地点、点赞和排行榜功能正常。
- 再接入OpenAI描述功能，并实现描述缓存，以降低调用频次和成本。
- 确保网格化逻辑正确性，让同一网格下的坐标使用同一location_id。
- 开发阶段使用简单的日志与监控，后续接入Datadog等服务进行性能分析与问题排查。
- 确保安全措施到位，包括HTTPS访问、CORS限制、基本的限流、参数校验等。
